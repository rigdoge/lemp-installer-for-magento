#!/bin/bash

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# 获取脚本所在目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
echo "Script directory: $SCRIPT_DIR"

# 加载配置
if [ -f "$SCRIPT_DIR/rabbitmq.monitor" ]; then
    echo "Loading RabbitMQ monitor config..."
    source "$SCRIPT_DIR/rabbitmq.monitor"
else
    echo "Error: RabbitMQ monitor config not found"
fi

# 加载通知库
if [ -f "$SCRIPT_DIR/../lib/notify.sh" ]; then
    echo "Loading notification library..."
    source "$SCRIPT_DIR/../lib/notify.sh"
else
    echo "Error: Notification library not found"
fi

# 发送告警邮件
send_alert_email() {
    local status="$1"
    local message="$2"
    
    if [ "$ENABLE_EMAIL_ALERT" = "true" ] && [ -f "$SMTP_SCRIPT" ]; then
        local subject="$ALERT_EMAIL_SUBJECT - $status"
        local body="RabbitMQ 监控告警\n\n状态: $status\n时间: $(date '+%Y-%m-%d %H:%M:%S')\n\n$message"
        
        "$SMTP_SCRIPT" "$ALERT_EMAIL_TO" "$subject" "$body" || {
            echo -e "${RED}错误：邮件发送失败${NC}"
            return 1
        }
    fi
}

# 检查是否为数字
is_number() {
    local num="$1"
    [[ "$num" =~ ^[0-9]+([.][0-9]+)?$ ]] && return 0 || return 1
}

# 检查 RabbitMQ 状态
check_rabbitmq_status() {
    echo "Checking RabbitMQ status..."
    
    local status_message=""
    local has_error=false
    local previous_status=0
    
    # 读取上一次的状态
    if [ -f "$STATUS_FILE" ]; then
        previous_status=$(cat "$STATUS_FILE")
    fi
    
    # 检查服务状态
    if ! systemctl is-active --quiet rabbitmq-server; then
        echo "RabbitMQ service is not running"
        send_notification "error" "RabbitMQ" "服务停止" "RabbitMQ 服务未运行"
        exit 1
    else
        echo "RabbitMQ service is running"
        send_notification "recovery" "RabbitMQ" "服务正常" "RabbitMQ 服务运行正常"
        # 如果服务恢复且上次状态为错误，发送恢复通知
        if [ "$previous_status" = "1" ]; then
            send_alert_email "恢复" "RabbitMQ 服务已恢复运行"
            echo -e "${GREEN}信息：RabbitMQ 服务已恢复运行${NC}"
        fi
    fi
    
    # 检查队列状态
    local queue_status=$(rabbitmqctl list_queues name messages consumers 2>/dev/null)
    if [ $? -ne 0 ]; then
        status_message="无法获取队列信息"
        has_error=true
        send_alert_email "错误" "$status_message"
        echo -e "${RED}错误：$status_message${NC}"
        echo "1" > "$STATUS_FILE"
        exit 1
    fi
    
    # 分析队列状态
    while read -r queue messages consumers; do
        if [ "$queue" != "Listing" ] && [ -n "$queue" ]; then
            # 验证消息数是否为数字
            if is_number "$messages"; then
                if [ "${messages%.*}" -gt "$MAX_QUEUE_SIZE" ]; then
                    status_message="队列 $queue 消息数量过多: $messages (超过 $MAX_QUEUE_SIZE)"
                    has_error=true
                    send_alert_email "警告" "$status_message"
                    echo -e "${YELLOW}警告：$status_message${NC}"
                fi
            fi
            
            # 验证消费者数是否为数字
            if is_number "$consumers"; then
                if [ "${consumers%.*}" -lt "$MIN_CONSUMERS" ]; then
                    status_message="队列 $queue 消费者数量不足: $consumers (少于 $MIN_CONSUMERS)"
                    has_error=true
                    send_alert_email "警告" "$status_message"
                    echo -e "${YELLOW}警告：$status_message${NC}"
                fi
            fi
        fi
    done <<< "$queue_status"
    
    # 检查内存使用
    local memory_usage=$(rabbitmqctl status 2>/dev/null | grep -A 5 "Memory" | grep "total" | awk '{print $2}')
    if is_number "$memory_usage"; then
        local total_memory=$(free -m | grep "Mem:" | awk '{print $2}')
        if is_number "$total_memory" && [ "$total_memory" -gt 0 ]; then
            local memory_percent=$((memory_usage * 100 / total_memory))
            
            if [ "$memory_percent" -gt "$MAX_MEMORY_USAGE" ]; then
                status_message="内存使用率过高: ${memory_percent}% (超过 ${MAX_MEMORY_USAGE}%)"
                has_error=true
                send_alert_email "警告" "$status_message"
                echo -e "${YELLOW}警告：$status_message${NC}"
            fi
        fi
    fi
    
    if [ "$has_error" = false ]; then
        echo -e "${GREEN}RabbitMQ 状态正常${NC}"
        echo "0" > "$STATUS_FILE"
        exit 0
    else
        echo "2" > "$STATUS_FILE"
        exit 2
    fi
}

check_queue() {
    local queue_name="$1"
    local messages=$(rabbitmqctl list_queues name messages | grep "^$queue_name\s" | awk '{print $2}')
    local consumers=$(rabbitmqctl list_queues name consumers | grep "^$queue_name\s" | awk '{print $2}')
    
    if [ -n "$messages" ] && [ "$messages" -gt 1000 ]; then
        send_notification "error" "RabbitMQ" "队列堆积" "队列 $queue_name 中有 $messages 条消息待处理"
        return 1
    fi
    
    if [ -n "$consumers" ] && [ "$consumers" -eq 0 ]; then
        send_notification "warning" "RabbitMQ" "无消费者" "队列 $queue_name 没有活动的消费者"
        return 2
    fi
    
    return 0
}

check_memory() {
    local memory_used=$(rabbitmqctl status | grep -A 5 "memory" | grep "total" | awk '{print $2}' | tr -d ',')
    local memory_limit=$(rabbitmqctl status | grep -A 5 "memory_limit" | grep "memory_limit" | awk '{print $2}' | tr -d ',')
    
    if [ -n "$memory_used" ] && [ -n "$memory_limit" ]; then
        local usage=$((memory_used * 100 / memory_limit))
        if [ $usage -gt 90 ]; then
            send_notification "error" "RabbitMQ" "内存使用过高" "内存使用率: ${usage}%"
            return 1
        elif [ $usage -gt 80 ]; then
            send_notification "warning" "RabbitMQ" "内存使用较高" "内存使用率: ${usage}%"
            return 2
        fi
    fi
    
    return 0
}

# 执行状态检查
check_rabbitmq_status
